name: Post-merge Branch Maintenance (disabled)

on:
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  rename-dev-branch:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Rename development branch after merge
        uses: actions/github-script@v7
        with:
          script: |
            const core = require('@actions/core');
            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // Configure source/target branch names here
            const OLD_BRANCH = 'ui/metrics-header';
            const NEW_BRANCH = 'dev';

            // Only act for same-repo branches
            const headRepo = pr.head.repo.full_name;
            const baseRepo = `${owner}/${repo}`;
            if (headRepo !== baseRepo) {
              core.info(`Head repo ${headRepo} is not base repo ${baseRepo}; skipping rename.`);
              return;
            }

            const headRef = pr.head.ref;
            if (headRef !== OLD_BRANCH) {
              core.info(`PR head branch '${headRef}' != '${OLD_BRANCH}'; nothing to rename.`);
              return;
            }

            core.info(`Renaming '${OLD_BRANCH}' to '${NEW_BRANCH}'...`);

            try {
              // Resolve current SHA of the old branch; fallback to PR head SHA if ref is gone
              let sha;
              try {
                const { data: ref } = await github.rest.git.getRef({
                  owner,
                  repo,
                  ref: `heads/${OLD_BRANCH}`,
                });
                sha = ref.object.sha;
                core.info(`Resolved '${OLD_BRANCH}' ref at ${sha}.`);
              } catch (e) {
                if (e.status === 404 && pr.head && pr.head.sha) {
                  sha = pr.head.sha;
                  core.info(`Old ref missing (possibly auto-deleted). Using PR head SHA ${sha}.`);
                } else {
                  throw e;
                }
              }

              // Create or update the target branch at the same commit
              try {
                await github.rest.git.createRef({
                  owner,
                  repo,
                  ref: `refs/heads/${NEW_BRANCH}`,
                  sha,
                });
                core.info(`Created '${NEW_BRANCH}' at ${sha}.`);
              } catch (e) {
                if (e.status === 422) {
                  await github.rest.git.updateRef({
                    owner,
                    repo,
                    ref: `heads/${NEW_BRANCH}`,
                    sha,
                    force: true,
                  });
                  core.info(`Updated existing '${NEW_BRANCH}' to ${sha}.`);
                } else {
                  throw e;
                }
              }

              // Delete the old branch ref
              await github.rest.git.deleteRef({ owner, repo, ref: `heads/${OLD_BRANCH}` });
              core.info(`Deleted old branch '${OLD_BRANCH}'.`);
            } catch (error) {
              core.setFailed(`Branch rename failed: ${error.message}`);
            }
